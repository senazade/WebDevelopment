"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _findUp = _interopRequireDefault(require("find-up"));

var _recommended = _interopRequireDefault(require("./config/recommended"));

var _collect = require("./collect");

var _getProgram = _interopRequireDefault(require("./get-program"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// $FlowIgnore
const DEFAULT_LOC = {
  start: {
    line: 1,
    column: 0
  },
  end: {
    line: 1,
    column: 0
  }
};

function lookupInfo(context, source, node) {
  const flowconfigFile = _findUp.default.sync('.flowconfig', {
    cwd: _path.default.dirname(context.getFilename())
  });

  if (flowconfigFile == null) {
    const program = (0, _getProgram.default)(source, node);
    context.report({
      loc: program ? program.loc : DEFAULT_LOC,
      message: "Could not find '.flowconfig' file"
    });
    return null;
  }

  const flowDir = _path.default.dirname(flowconfigFile);

  const runOnAllFiles = _fs.default.readFileSync(flowconfigFile, 'utf8').includes('all=true');

  const shouldRun = runOnAllFiles || source.getAllComments().some(comment => /@flow/.test(comment.value));
  const program = shouldRun && (0, _getProgram.default)(source, node);

  if (program) {
    return {
      flowDir,
      program
    };
  }

  return null;
}

function stopOnExit(context) {
  return !!(context.settings && context.settings['flowtype-errors'] && context.settings['flowtype-errors'].stopOnExit);
}

function errorFlowCouldNotRun(loc) {
  return {
    loc,
    message: `Flow could not be run. Possible causes include:
  * Running on 32-bit OS (https://github.com/facebook/flow/issues/2262)
  * Recent glibc version not available (https://github.com/flowtype/flow-bin/issues/49)
  * FLOW_BIN environment variable ${process.env.FLOW_BIN ? 'set incorrectly' : 'not set'}
.`
  };
}

function createFilteredErrorRule(filter) {
  return function showErrors(context) {
    return {
      Program(node) {
        const source = context.getSourceCode();
        const info = lookupInfo(context, source, node);

        if (!info) {
          return;
        }

        const {
          flowDir,
          program
        } = info;
        const collected = (0, _collect.collect)(program.text, flowDir, stopOnExit(context), context.getFilename(), program.offset);

        if (collected === true) {
          return;
        }

        if (collected === false) {
          context.report(errorFlowCouldNotRun(program.loc));
          return;
        }

        collected.filter(filter).forEach(({
          loc,
          message
        }) => {
          context.report({
            loc: loc ? { ...loc,
              start: { ...loc.start,
                // Flow's column numbers are 1-based, while ESLint's are 0-based.
                column: loc.start.column - 1
              }
            } : loc,
            message
          });
        });
      }

    };
  };
}

var _default = {
  configs: {
    recommended: _recommended.default
  },
  rules: {
    'enforce-min-coverage': function enforceMinCoverage(context) {
      return {
        Program(node) {
          const source = context.getSourceCode();
          const info = lookupInfo(context, source, node);

          if (!info) {
            return;
          }

          const {
            flowDir,
            program
          } = info;
          const res = (0, _collect.coverage)(program.text, flowDir, stopOnExit(context), context.getFilename());

          if (res === true) {
            return;
          }

          if (res === false) {
            context.report(errorFlowCouldNotRun(program.loc));
            return;
          }

          const requiredCoverage = context.options[0];
          const {
            coveredCount,
            uncoveredCount
          } = res;
          /* eslint prefer-template: 0 */

          const percentage = Number(Math.round(coveredCount / (coveredCount + uncoveredCount) * 10000) + 'e-2');

          if (percentage < requiredCoverage) {
            context.report({
              loc: program.loc,
              message: `Expected coverage to be at least ${requiredCoverage}%, but is: ${percentage}%`
            });
          }
        }

      };
    },
    'show-errors': createFilteredErrorRule(({
      level
    }) => level !== _collect.FlowSeverity.Warning),
    'show-warnings': createFilteredErrorRule(({
      level
    }) => level === _collect.FlowSeverity.Warning)
  }
};
exports.default = _default;